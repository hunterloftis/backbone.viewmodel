<!DOCTYPE html>
<html>
<head>
  <title>Backbone.ViewModel Virtuals Fiddle</title>
</head>
<body>

  We need a way to pass more complex parameters into bindings.

  css needs to know: 'css' type, [list] of class:value pairs
  click needs to know: 'click' type, fn() to call, [arguments] to fn()

  css: { dark: true } // should work
  css: { dark: isDark } // should work

  click: setUser(0) // should work
  click: setUser(activeUser) // maybe should work

  val: someAttr // should work
  val: { data: someAttr, trigger: 'keyup change' } // should work

  should look for special values: undefined, null, numeric, strings, true/false

  could also go with a function-like syntax:

  css(dark, true)
  css(dark, isTrue)

  click(setUser, 0)
  click(setUser, activeUser)

  val(someAttr)
  val(someAttr, 'keyup change')

  ...benefits include more direct mapping (each function = a binding, 1:1)
  and concise, familiar syntax with less punctuation

  Also, the functional style can continue into binding definitions, where
  we can implement something like:

  var ClickBinding = Backbone.Binding.extend({
    initialize: function(attr, val)
  })

  var ValueBinding = Backbone.Binding.extend({
    initialize: function(attr, events)
  })

  <!-- Bound View -->
  <div data-style='css(dark, isDark); css(big, isBig)'>
    <a href='#' data-switch='click(setUser, 0)'>First user</a>
    <a href='#' data-switch='click(setUser, 1)'>Second user</a>

    <input data-editor='val(first)' placeholder='first'></div>
    <input data-editor='val(last)' placeholder='last'></div>

    <p data-profile='text(fullname)'></p>
  </div>

  <!-- Platform dependencies -->
  <script src='../vendor/zepto-1.0rc1.js'></script>
  <script src='../vendor/underscore-1.3.3.js'></script>
  <script src='../vendor/backbone-0.9.2.js'></script>

  <!-- Backbone.ViewModel -->
  <script src='../backbone.viewmodel.js'></script>
  <script src='../backbone.virtual.js'></script>
  <script src='../backbone.binding.js'></script>
  <script src='../lib/bindings.js'></script>

  <script>

    // Users collection - the data model being manipulated
    var users = [
      new Backbone.Model({
        first: 'Hunter',
        last: 'Loftis',
        zip: ''
      }),
      new Backbone.Model({
        first: 'Amy',
        last: 'Lynn',
        zip: ''
      })
    ];

    // Switch - manages which user model is active
    var switchVM = new Backbone.ViewModel({
      model: users,
      userIndex: 0,
      firstUser: function() {
        this.set('userIndex', 0);
      },
      secondUser: function() {
        this.set('userIndex', 1);
      }
    });
    // TODO: the difference between this (with `attr`) and the editor
    // virtual (without arguments) is non-obvious. Find a better
    // syntax to differentiate between a getter-only definition (as here)
    // and a model-evaluation definition (as below)
    //
    // It may be a good idea to alias 'virtual' with different signatures
    // eg, switchVM.compute() would take a single get()
    // switchVM.pass() would take a model-evaluator fn() or a model instance
    // switchVM.virtual() would take the full object
    switchVM.virtual('activeUser', function get(attr) {
      var model = this.get('model');
      var index = this.get('userIndex');
      return model[index];
    });
    switchVM.bindView('data-switch');

    // Editor - edits the active user model
    var editorVM = new Backbone.ViewModel();
    editorVM.virtual('first', 'last', function model() {
      return switchVM.get('activeUser');
    });
    editorVM.bindView('data-editor');

    // Profile - displays transformed data from the active user model
    var profileVM = new Backbone.ViewModel();
    profileVM.virtual('fullname', function(attr) {
      return switchVM.get('activeUser').get('first') + ' ' + switchVM.get('activeUser').get('last');
    });
    profileVM.bindView('data-profile');

  </script>

</body>
</html>